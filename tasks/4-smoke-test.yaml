apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: smoke-test-dev
  namespace: mq
spec:
  params:
    - name: git-url
    - name: git-clone
    - name: git-revision
    - name: source-dir
    - default: ""
      name: image-server
    - name: image-namespace
    - default: ""
      name: image-repository
    - name: image-tag
    - name: app-namespace
    - name: app-name
    - name: security
    - name: ha
    - name: deploy-ingress-type
    - name: tools-image
    - name: subdirectory
    - name: GIT_SECRET
    - name: IMAGE

  steps:
    - name: git-pull
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              key: password
              name: $(params.GIT_SECRET)
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              key: username
              name: $(params.GIT_SECRET)
              optional: true
        - name: GIT_EMAIL
          valueFrom:
            secretKeyRef:
              key: email
              name: $(params.GIT_SECRET)
              optional: true
      image: >-
        docker.io/alpine/git:v2.26.2@sha256:23618034b0be9205d9cc0846eb711b12ba4c9b468efdd8a59aac1d7b1a23363f
      resources: {}
      script: |

        # Setting up the config for the git.

        pwd
        ls

        rm -rf $(params.subdirectory)

        git config --global user.email "$GIT_EMAIL"
        git config --global user.name "$GIT_USERNAME"

        $(params.git-clone)

        RESULT_SHA="$(git rev-parse HEAD | tr -d '\n')"
        EXIT_CODE="$?"
        if [ "$EXIT_CODE" != 0 ]
        then
          exit $EXIT_CODE
        fi
        ls
        cd $(params.subdirectory)
        ls
        pwd
      volumeMounts:
        - mountPath: /source
          name: source
      workingDir: /source
    - image: $(params.tools-image)
      name: deploy
      resources: {}
      script: >
        #!/usr/bin/env bash

        cd $(params.subdirectory)

        set -ex

        GIT_URL="$(params.git-url)"

        # GIT_REVISION="$(params.git-revision)"

        APP_NAMESPACE="$(params.app-namespace)"

        APP_NAME="$(params.app-name)"

        if [[ -z "${APP_NAME}" ]]; then
          APP_NAME="$(params.image-repository)"
        fi

        # IMAGE_SERVER="$(params.image-server)"

        # IMAGE_NAMESPACE="$(params.image-namespace)"

        # IMAGE_REPOSITORY="$(params.image-repository)"

        IMAGE_VERSION="$(params.image-tag)"

        IMAGE_URL="$(params.IMAGE)"

        INGRESS_TYPE="$(params.deploy-ingress-type)"

        if [[ "${INGRESS_TYPE}" == "route" ]]; then
          ROUTE_ENABLED="true"
          INGRESS_ENABLED="false"
        else
          ROUTE_ENABLED="false"
          INGRESS_ENABLED="true"
        fi

        export CHART_ROOT=$(find . -name chart)

        echo "CHART_ROOT: $CHART_ROOT"

        FILE_NUM=$(find . -name 'Chart*.yaml' |wc -l)

        if [[ "${FILE_NUM}" -gt 1 ]]; then
          echo "Error: Found >1 Chart*.yaml"
          exit 1
        fi

        export CHART=$(find . -name 'Chart*.yaml')

        echo "CHART: $CHART"

        export CHART_NAME=$(cat $CHART | yq r - name)

        echo "CHART_NAME: $CHART_NAME"

        ls

        # Update Chart name and version

        if [[ "${CHART_NAME}" != "${APP_NAME}" ]]; then
          echo "Renaming chart from ${CHART_NAME} to ${APP_NAME}"
          cp -R "${CHART_ROOT}/${CHART_NAME}" "${CHART_ROOT}/${APP_NAME}"
          cat "${CHART_ROOT}/${CHART_NAME}/Chart.yaml" | \
              yq w - name "${APP_NAME}" | \
              yq w - version "1.0.0-rc${IMAGE_VERSION}" > "${CHART_ROOT}/${APP_NAME}/Chart.yaml"
        else
          echo "Chart name and image name match: ${APP_NAME}"
        fi

        CHART_PATH="${CHART_ROOT}/${APP_NAME}"

        RELEASE_NAME="${APP_NAME}"

        echo "RELEASE_NAME: $RELEASE_NAME"

        echo $(helm version)

        echo "CHECKING CHART (lint)"

        helm lint ${CHART_PATH}

        PREFIX=""

        if [[ -f "${CHART_PATH}/requirements.yaml" ]] || grep -Eq
        "^dependencies:" "${CHART_PATH}/Chart.yaml"; then
            DEPENDENCY_FILE="${CHART_PATH}/Chart.yaml"
            if [[ -f "${CHART_PATH}/requirements.yaml" ]]; then
                DEPENDENCY_FILE="${CHART_PATH}/requirements.yaml"
            fi

            PREFIX="$(yq r -j "${DEPENDENCY_FILE}" | jq -r '.dependencies | .[] | .alias // .name' | head -1)."
        fi

        # Update helm chart with repository and tag values

        cat ${CHART_PATH}/values.yaml | \
            yq w - "${PREFIX}nameOverride" "${APP_NAME}" | \
            yq w - "${PREFIX}fullnameOverride" "${APP_NAME}" | \
            yq w - "${PREFIX}vcsInfo.repoUrl" "${GIT_URL}" | \
            yq w - "${PREFIX}vcsInfo.branch" "${GIT_REVISION}" | \
            yq w - "${PREFIX}image.repository" "${IMAGE_URL}" | \
            yq w - --style single "${PREFIX}image.tag" "${IMAGE_VERSION}" | \
            yq w - "${PREFIX}ingress.enabled" "${INGRESS_ENABLED}" | \
            yq w - "${PREFIX}route.enabled" "${ROUTE_ENABLED}" > ./values.yaml.tmp
        cp ./values.yaml.tmp ${CHART_PATH}/values.yaml

        cat ${CHART_PATH}/values.yaml

        helm dep update "${CHART_PATH}"

        # Using 'upgrade --install" for rolling updates. Note that subsequent
        updates will occur in the same namespace the release is currently
        deployed in, ignoring the explicit--namespace argument".

        helm template ${RELEASE_NAME} ${CHART_PATH} \
            --namespace ${APP_NAMESPACE} \
            --set ${PREFIX}ingress.tlsSecretName="${TLS_SECRET_NAME}" \
            --set ${PREFIX}ingress.subdomain="${INGRESS_SUBDOMAIN}" \
            --set security="$(params.security)" \
            --set ha="$(params.ha)" > ./release.yaml

        echo -e "Generated release yaml for: ${APP_NAMESPACE}/${APP_NAME}"

        cat ./release.yaml

        echo -e "Deploying into: ${APP_NAMESPACE}/${APP_NAME}"

        kubectl apply -n ${APP_NAMESPACE} -f ./release.yaml --validate=false >
        results.out

        cat results.out

        echo "Waiting for rollout of ${APP_NAMESPACE}/${APP_NAME}"

        cat results.out | \
          grep -E "deployment|statefulset|integrationserver|queuemanager" | \
          sed "s/deployment.apps/deployment/g" | \
          sed "s/statefulset.apps/statefulset/g" | \
          sed "s/configured//g" | \
          sed "s/created//g" | \
          sed "s/unchanged//g" | while read target; do
          echo "Waiting for rollout of ${target} in ${APP_NAMESPACE}"
          if [[ ${target} == *"integrationserver"* ]]; then
            kubectl wait --timeout=-1s --for=condition=Ready ${target}
          elif [[ ${target} == *"queuemanager"* ]]; then
            until [[ "$(kubectl get ${target} -o 'jsonpath={.status.phase}')" = "Running" ]];
            do
            sleep 5
            echo "Waiting for Queuemanager to be ready."
            done
          else
            kubectl rollout status -n ${APP_NAMESPACE} ${target}
            SERVICE_PORT=$(kubectl get svc "${APP_NAME}" -n "${APP_NAMESPACE}" -o jsonpath="{.spec.ports[?(@.name == 'http')].port}")
            echo -n "${SERVICE_PORT}" | tee $(results.service-port.path)
          fi
          echo -n "${target}" | cut -f1 -d / | tee $(results.resource-type.path)
        done
      securityContext:
        privileged: true
      volumeMounts:
        - mountPath: /source
          name: source
      workingDir: /source
    - image: $(params.tools-image)
      name: health-check
      resources: {}
      script: >
        #!/usr/bin/env bash

        ls

        set -x


        APP_NAME="$(params.app-name)"


        RELEASE_NAME="${APP_NAME}"

        echo "RELEASE_NAME: $RELEASE_NAME"


        podname=$(kubectl get pods --selector=app.kubernetes.io/instance=$RELEASE_NAME -o custom-columns=POD:.metadata.name --no-headers | head -n 1)

        # podname=${APP_NAME}-ibm-mq-0

        echo "podname: $podname"


        queue="QM1"

        echo "queue name: $queue"


        echo "Sleep before test to make sure QMGR is up"

        sleep 20


        echo "Print the queue details: ..."

        echo ""

        kubectl exec $podname -- /bin/bash -c "echo \"define qlocal($queue)
        replace\" | runmqsc "


        echo "Print the queue details: ..."

        echo ""

        kubectl exec $podname -- /bin/bash -c "echo \"DISPLAY QL($queue) ALL\" |
        runmqsc" > checkQ.txt 2>&1

        cat checkQ.txt


        if grep -q "QUEUE($queue)" checkQ.txt; then
          echo "Queue has been successfully created."
        else
          exit 1
        fi


        # put message on queue

        kubectl exec $podname -- /bin/bash -c "echo \"hello-world\" |
        /opt/mqm/samp/bin/amqsput $queue" > putMessage.txt 2>&1

        cat putMessage.txt

        echo "----------"

        fail="reason code"

        if grep -q "$fail" putMessage.txt; then
          exit 1
        else
          echo "Message has been successfully put the queue."
        fi


        # get message on queue

        kubectl exec $podname  -c qmgr -- /opt/mqm/samp/bin/amqsget $queue >
        getMessage.txt 2>&1

        cat getMessage.txt

        if grep -q "hello-world" getMessage.txt; then
            echo "Message has been found on the queue."
        else
            echo "Error: Message has not been retrieved from the queue."
            exit 1
        fi


        echo "PWD ....."

        pwd


        echo "list of files....."

        ls

      securityContext:
        privileged: true
      volumeMounts:
        - mountPath: /source
          name: source
      workingDir: /source
    - image: $(params.tools-image)
      name: cleanup
      resources: {}
      script: |
        #!/usr/bin/env bash

        cat release.yaml

        set -ex

        APP_NAMESPACE="$(params.app-namespace)"

        # kubectl delete -n ${APP_NAMESPACE} -f ./release.yaml
      securityContext:
        privileged: true
      volumeMounts:
        - mountPath: /source
          name: source
      workingDir: /source
  volumes:
    - name: source
      emptyDir: {}
